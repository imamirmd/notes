
### Memory & Swap Management 

```shell
sudo docker run -m 400M --memory-swap 1G nginx
```

- **`-m 400M` / `--memory 400M`**  
	Limits the container to **400 MB of RAM**.

- **`--memory-swap 1G`**  
    Sets the **total memory + swap** limit to **1 GB**.  

	That means:    
	- RAM: **400 MB**
	- Swap: up to **600 MB**

```shell
sudo docker run -m 400M nginx # Swap equals RAM (400M + 400M)
```

- Swap is **enabled automatically** and equals memory limit.

```shell
sudo docker --memory-swap 1G nginx # error
```

- You cannot set swap without setting RAM.

```shell
sudo docker run -m 400M --memory-swap -1 nginx # Swap unlimited
```

- Container can swap as much as the host allows.

```shell
sudo docker run -m 400M --memory-swap 400M nginx
```

- If RAM is exhausted → **OOM kill**

---
### CPU Management 

```shell
lscpu | grep -i "^CPU(s):" # total number of CPU cores
```

```shell
sudo docker run --cpuset-cpus="0,2" nginx
```

```shell
sudo docker inspect bbox -f '{{.HostConfig.CpusetCpus}}'
```

-  `--cpuset-cpus`
	restricts a container to run **only on specific CPU cores**

---
### Update Container Config

> applies changes dynamically to a running container without requiring a restart, as long as the container is already active.

```shell
sudo docker update <options> <container>
```

```shell
sudo docker update --memory 1G nginx
```

```shell
sudo docker update --cpuset-cpus="1" nginx
```

---
### Storage Management

```shell
sudo docker run --storage-opt size=10G ngnix
```

- `--storage-opt`
	lets you **set storage-specific options** for a container, such as limiting how much disk space it can use (depending on the storage driver).

- Limits the container’s writable layer to **10 GB**
- Works with drivers like **overlay2** (on supported filesystems)

> **`pquota`** is a **filesystem mount option** (mainly for **XFS**) that enables **project quotas**, which Docker uses to **enforce disk size limits** on containers.

- Docker’s `--storage-opt size=...` needs **XFS with `pquota` enabled**
- `pquota` lets the filesystem **track and limit disk usage per container**
- Without `pquota`, Docker **cannot enforce writable-layer size limits**

> if your system is using **ext4**, so **pquota is not enabled and cannot be enabled**.  To use Docker storage quotas, you need **XFS mounted with `pquota` / `prjquota`**. 

**Note**: On ext4, `--storage-opt size` is accepted but **not enforced**.

---
### Enabling `pquota`

```shell
mount | grep xfs # YOU NEED TO BE XFS
```

```shell
sudo nano /etc/default/grub
```

```shell
GRUB_CMDLINE_LINUX_DEFAULT="rootflags=uquota,pquota"
```

```shell
sudo grub-mkconfig -o /boot/grub/grub.cfg
```

```shell
reboot
```

---
### Container Statistics

> Display a live stream of container(s) resource usage statistics

```shell
sudo docker stats <container(s)>
```

```shell
sudo docker stats --no-stream 
```

---
### Docker `tag`

> used to create an alias or label for an existing Docker image, allowing you to assign a new name or version tag to it without altering the image itself.

```shell
sudo docker tag <repository:tag> <new-repository:new-tag>
```

---
### Dangling Image

> A **dangling image** is a Docker image that **has no tag** and is **not referenced by any container**, usually left behind after rebuilding images.

```shell
sudo docker images --filter dangling=true
```

**Note**: You get **dangling images** when Docker creates new image layers and the old ones **lose their tags**.

```shell
sudo docker image prune # Deletes dangling images only
```

Useful options:

- `-a` → remove **all unused images** (not just dangling ones)
- `-f` → skip confirmation

---
### Docker `search` 

>  for searching images on Docker Hub (or other registries) based on a search term you provide in place of `<query>`, such as `nginx` or `redis`.

```shell
sudo docker search <query>
```

 - `--limit 10` Restrict to top 10 results (default is 25, max 100)
- `--filter stars=100`  Show only images with 100+ stars for popularity
- `--filter is-official=true` Limit to official images from trusted sources
- `--no-trunc` Display full descriptions without cutting them short

---
### Object low-level information

> used to retrieve detailed, low-level information about a Docker object, such as a container, image, network, or volume, by specifying its name or ID in place of `<object>`.

> It outputs data in JSON format, covering aspects like configuration, state, mounts, environment variables, network settings, and more, which is invaluable for debugging, auditing, or scripting.

```shell
sudo docker inspect <object>
```

- `--format '{{.Some.Field}}'` Extract specific fields using Go templates for cleaner output.

- `--type container` Specify the object type (e.g., container, image, volume) to avoid ambiguity if names overlap.

```shell
sudo docker inspect --format '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container>
```

---
### Remove Container

```shell
sudo docker rm <container> 
```

- Removes a stopped container from the system.

```shell
sudo docker rm -f <container> 
```

- Force-stops a running container and removes the container immediately.

```shell
sudo docker rm -f $(sudo docker ps -aq)
```

- Force-stops **all running containers** and removes **all containers** on the system.

```shell
sudo docker rm -v <container>
```

- Deleting the container with anonymous volumes attached to it.

```shell
sudo docker rm $(docker ps -a -q -f status=exited)
```

- To remove all stopped containers

**Note**: The content inside the container is not deleted as long as the container exists.

---
### Remove Image

```shell
sudo docker rmi <image>
```

- Removes an image tag; if the image is **tagged**, only that tag is deleted (layers stay if still referenced), but if **any container exists from the image**, removal is blocked unless forced, because the image is in use.

```shell
sudo docker rmi -f <image>
```

- Force-removes the image **and automatically stops and deletes any running containers** that were created from that image.

> When a container is **running**, Docker **cannot delete the image layers**, so with `docker rmi -f` it **only removes the tag**, not the actual image data.  

> The image becomes **untagged (dangling)**, but the **layers stay on disk** because the running container still depends on them.

> As long as the container exists, **it is not possible to delete its image.**

---
### Docker `attach`

> used to attach your terminal session to a running Docker container, allowing you to interact directly with its primary process (e.g., view output, send input, or control it as if you were inside).

> It connects your `stdin`, `stdout`, and `stderr` to the container's main process, which is useful for debugging or monitoring long-running services without needing a separate shell.

> To detach without stopping the container, press Ctrl+P followed by Ctrl+Q.


```shell
sudo docker attach <container>
```

- `--no-stdin` Attach only for output viewing, without sending input (e.g., `sudo docker attach --no-stdin <container>`).

- `--sig-proxy=false` Disable signal proxying to the container process (default is true, so Ctrl+C kills the attached process).

---
### Docker `exec`

> used to execute a specified command (`<command>`) inside a running container identified by its name or ID (`<container>`), without starting a new container or attaching your terminal interactively. 

```shell
sudo docker exec [<options>] <container> <command>
```

```shell
sudo docker -it busybox sh
```

- **`-i`** keeps standard input open
- **`-t`** allocates a pseudo-terminal (TTY)

```shell
sudo docker exec -w /bin busybox ls
```

- **`-w /bin`** → set the working directory inside the container to `/bin`

```shell
sudo docker exec -it -e FLAG=1 busybox sh
# or
sudo docker exec -it -e FLAG=1 -e NAME=busybox busybox sh
```

- **`-e FLAG=1`** sets an environment variable `FLAG` with value `1` for this process

```shell
sudo docker exec -d busybox touch /tmp/file
```

- `-d` Run in detached (background) mode

```shell
sudo docker exec -u nginx busybox whoami
```

- `-u <user>` Execute as a specific user.

---
### Copy Files/Folders

> used to copy files or directories between a container and the host machine (or between containers), where <source> is the origin path and `<destination>` is the target path. 

> It works on both running and stopped containers, treating the paths as either local host filesystems or container-internal paths (prefixed with the container name/ID).

```shell
sudo docker cp <source> <destination>
```

```shell
sudo docker cp text.txt busybox:/home
```

```shell
sudo docker cp busybox:/home/pass.txt ./
```

```shell
sudo docker cp ngnix:/conf/httpd.conf ubunt:/ # between containers
```

```shell
sudo docker cp -a text.txt busybox:/home
```

  - `-a ` preserves the file’s **attributes** (permissions, ownership, timestamps, symlinks), so `text.txt` inside the container stays **exactly the same** as on the host instead of being copied with default metadata.

**Note**: In newer versions, using the `-a` flag does not make any difference in the result, and it behaves as `-a` by default.


