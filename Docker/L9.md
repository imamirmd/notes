### Docker Compose 

> **Docker Compose** is a tool that lets you **define and run multi-container Docker applications** using a single configuration file (usually `docker-compose.yml`).

```shell
sudo docker compose version
```

> YAML (YAML Ain’t Markup Language) is a human-readable file format used mainly for configuration files, where data is written using simple indentation instead of brackets or symbols; it’s commonly used in tools like Docker Compose, Kubernetes, and CI/CD pipelines because it’s easy to read, write, and maintain, supports lists and key-value pairs, and helps define how applications and services should run or connect to each other.

> Running multiple Docker Compose files at the same time is **not possible by default**, because each `docker compose` command manages its own project scope, and conflicts can occur if services, networks, or ports overlap. However, you _can_ run multiple Compose files simultaneously **as long as they use different project names, networks, or resources**, or by explicitly combining them using the `-f` option.

```yml
services:
	web:
		build: .
		ports:
			- "8080:8080"
		links:
			- "redis:database"
		networks:
			- pnet
	redis:
		image: "redis:alpine"
		networks:
			- pnet
networks:
	pnet
```

```shell
sudo docker compose up [-d]
```

- `-d` starts all services defined in the Compose file and runs them in the background.

```shell
sudo docker compose [ps [-a] | images [-a] | top]
```

- `ps` shows running containers in the Compose project,
- `images` lists the images used by that project.
- `top` shows the running processes inside each container of the Compose project.

```shell
sudo docker compose [stop | start | restart]
```

- `stop | start | restart` stops, starts, or restarts all services defined in the Compose project.

```shell
sudo docker compose down [-v]
```

- `down` stops and removes all containers, networks, and default resources created by the Compose project. (`-v` also volumes)

```shell
sudo docker compose config
```

- validates and prints the fully merged and resolved Compose configuration.

```shell
sudo docker compose [pause | unpuase]
```

- `pause | unpause` pauses or resumes all running containers in the Compose project without stopping them.

```shell
sudo docker compose logs [-f |& -t]
```

- shows the logs output from all services in the Compose project.

> By default, Docker Compose automatically creates **one isolated bridge network** per project, and all services are attached to it.

- One network per Compose project
- Automatic DNS-based service discovery
- Containers can talk to each other
- External access requires port mapping

**External network**

> This configuration tells Docker Compose to **use an existing external network instead of creating a new one**.

```yml
services:
	web:
		build: .
		ports:
			- "8080:8080"
	redis:
		image: "redis:alpine"
			  
networks:
	default:
		external: true
		name: <name>
```

**Compose File Version**

> The **Compose file version format** defines **which features and syntax Docker Compose understands** in a `docker-compose.yml` file. It tells Docker **how to interpret the file**, not which Docker version you’re using.

> With **Docker Compose v2+**, the `version` field is **optional**.

---
#### `build:`

> `build:` in Docker Compose tells Docker **how to build an image from a Dockerfile instead of pulling one from a registry**.

```yml
build: .
```

- Build the image using the `Dockerfile` in the current directory.

```yml
build:
	context: .
    dockerfile: Dockerfile.dev
```

-  Using a specific Dockerfile

```yml
build:
	context: .
    args:
	    NODE_ENV: production
```

- Passing build arguments

```yml
build:
  context: .
  target: production
```

- Builds only a specific stage from a multi-stage Dockerfile.

```yml
build:
  context: .
  no_cache: true
```

- Forces Docker to rebuild everything without using cache.

```yml
image: myapp:1.0
```

- Names and tags the built image.

```yml
build: ./docker-file
image: alpha:v1
```

```yml
build:
	context: ./docker-file
image: alpha:v1
```

```yml
build:
	context: ./docker-file
	dockerfile: dockerfile.dev
image: alpha:v1
```

```shell
# Equivalent CLI command:
docker build -t alpha:v1 ./docker-file
```

- Docker will **build an image using the** `Dockerfile` or `dockerfile.dev` **located in** `./docker-file`, and then **tag the resulting image as `alpha:v1`**.

#### `command:`

> `command:` in Docker Compose **overrides the default command (`CMD`) defined in the image** and tells the container **what to run when it starts**.

```yml
command: ["npm", "start"]
```

#### `ports:`

> creates a **port mapping between the host machine and the container**. It allows traffic from **outside Docker** to reach a service **inside a container**.

```yml
ports:
  - "HOST_PORT:CONTAINER_PORT"
```

```yml
ports:
  - "8080:80"
```

- App listens on **port 80 inside the container**
- You access it via **localhost:8080** on your machine

```yml
ports:
  - "127.0.0.1:8080:80"
```

- Only accessible from **localhost**
- Not exposed to the network

```yml
ports:
  - target: 80
    published: 8080
    protocol: tcp
```

#### `networks:`

> Docker Compose defines **which network(s) a service connects to** and **how containers communicate with each other**.

```yml
networks:
  mynet:
    driver: bridge
```

```yml
networks:
	default:
		external: true
		name: <name>
```

```yml
networks:
	pnet:
		external: true
		name: <name>
```

#### `volumes:`

> Docker Compose are used to **store and share data outside the container’s lifecycle**, so data **persists even if the container is deleted**.

```yml
services:
  db:
    image: mysql
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:
```

**Bind mounts (host ↔ container)**

```yml
volumes:
  - ./app:/app
```

**Read-only mounts**

```yml
volumes:
  - ./config:/etc/app:ro
```

**Anonymous volumes**

```yml
volumes:
  - /data
```

**tmpfs**

```yml
volumes:
  - type: tmpfs
    target: /app/tmp
```

#### `container_name:`

> lets you **manually set a fixed name for a container** instead of Docker generating one automatically.

```yml
services:
  app:
    image: nginx
    container_name: my-nginx
```

**Note**l: Use `container_name` **only when necessary** (e.g., debugging or legacy setups).  Avoid it in production or scalable systems.

#### `depends_on:`

> used to **control the startup order of services** in Docker Compose.

- Ensures **startup order only**
- Does **NOT** wait for the service to be _ready_
- Just waits until the container **starts**

```yml
services:
  app:
    depends_on:
      - db
  db:
    image: postgres
```

- Docker starts `db` **before** `app`.

#### `healthcheck:`

> used to **tell Docker how to check if a container is actually healthy and ready to work**, not just running.

```yml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:3000"]
  interval: 10s
  timeout: 5s
  retries: 3
```

- **`test`** → the command used to check health
- **`interval`** → how often the check runs
- **`timeout`** → how long to wait before failing
- **`retries`** → how many failures before marking unhealthy

```yml
services:
  db:
    image: postgres
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 5s
      retries: 5

  app:
    depends_on:
      db:
        condition: service_healthy
```

- `service_started` 
	- Starts the service **as soon as the container starts**
	- Does **NOT** wait for readiness
	- Equivalent to plain `depends_on`

-  `service_healthy`
	- Waits until the service passes its `healthcheck`
	- Requires a `healthcheck` to be defined

- `service_completed_successfully`
	- Waits until the service **exits with code 0**
	- Used for one-time jobs or migrations

```yml
services:
  db:
    image: postgres
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 5s
      retries: 5
      start_period: 40s

  migrate:
    image: my-migration
    depends_on:
      db:
        condition: service_healthy

  app:
    depends_on:
      migrate:
        condition: service_completed_successfully
```

> `condition` controls **when** a dependent service starts based on the state of another service.

#### `environment:`

> used to **set environment variables inside a container**.

```yml
environment:
  APP_ENV: production
  DEBUG: "false"
```

or

```yml
environment:
  - DB_HOST=${DB_HOST}
```

| Docker reads values from a `.env` file:

```env
DB_HOST=localhost
```

| Difference from `env_file`

```yml
env_file:
  - .env
```

**List format**

```yml
environment:
  - NODE_ENV=production
  - PORT=3000
```

```yml
services:
  app:
    image: node:20
    container_name: my_app
    working_dir: /app
    volumes:
      - ./app:/app
    command: node app.js
    ports:
      - "3000:3000"

    environment:
      APP_NAME: ${APP_NAME}
      PORT: ${APP_PORT}
      DATABASE_HOST: ${DB_HOST}
      DATABASE_USER: ${DB_USER}
      DATABASE_PASS: ${DB_PASS}

  db:
    image: postgres:15
    env_file:
      - db.env
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASS}
```

#### `expose:`

> used to **document and allow internal container-to-container communication**, without exposing ports to the host.

```yml
services:
  api:
    image: my-api
    expose:
      - "3000"
```

- The container listens on **port 3000**
- Other containers **on the same network** can access it
- The port is **NOT accessible from the host**

#### `restart:`

> `restart` defines **what Docker should do when a container stops or crashes**.

```yml
services:
  api:
    image: my-api
    restart: unless-stopped
```

#### `tmpfs:`

> `tmpfs` is a **temporary in-memory filesystem** used by containers to store data **in RAM instead of disk**.

```yml
tmpfs:
  - /tmp
```

- `/tmp` exists **only in memory**
- Data is **lost when the container stops**

```yml
tmpfs:
  - /run:size=64m,mode=1777
```

- `size` → memory limit
- `mode` → permissions

```yml
services:
  app:
    image: nginx
    tmpfs:
      - /tmp
```



