### Dockerfile

> **Dockerfile** is a **text file that defines how a Docker image is built**. It contains step-by-step instructions that tell Docker what base image to use, what software to install, what files to copy, and how the container should run.

| **A Dockerfile describes:**

- The base operating system or image
- Dependencies to install
- Files to copy into the image
- Environment variables
- The command that runs when the container starts

> A **`.dockerignore`** file tells Docker **which files and directories to exclude** when building an image.

#### `FROM`

> Defines the **base image**.

```dockerfile
FROM ubuntu:latest
```

```shell
sudo docker build -t <name>:<tag> .
```

#### `LABEL`

> Adds metadata to the image.

```dockerfile
LABEL version="1.0.0"
LABEL maintinaer="alpha"
```

#### `COPY`

> Copies files from host → image.

```dockerfile
COPY app.py /home/
```

```dockerfile
COPY --chown=1000:1000 app.py /home 
```

```dockerfile
COPY --from=<stage> <stage-source> <destination>
```

#### `ADD`

> Like `COPY`, but with extra features:

- Can extract archives
- Can download URLs

```dockerfile
ADD app.py /home/
ADD test.tar.gz /home/
ADD --chown=1000:1000 main.py /home/
```

```dockerfile
ADD https://example.com/main.tar.gz /opt/data/
```

**Note**: When a file is provided as a URL, it is not extracted.

#### `RUN`

> `RUN` executes commands **during the image build process** and creates a **new image layer** with the result.

**Shell form (runs inside `/bin/sh -c`)**

```dockerfile
RUN apt update && apt install -y curl
```

**Exec form (recommended for clarity)**

```dockerfile
RUN ["apt-get", "install", "-y", "curl"]
```

```dockerfile
RUN --mount=type=cache,target=/root/.cache pip install -r requirements.txt
```

- Docker creates a **cache directory outside the image**
- Mounts it temporarily during the `RUN` step
- Reuses it in future builds
- Removes it from the final image layers

> The **shell form** runs commands through a shell (`/bin/sh -c`), which allows features like pipes, redirects, and environment variable expansion, but adds an extra shell process and can cause signal-handling issues. The **exec form** runs the command directly without a shell, passing arguments exactly as written, which makes it more predictable, safer, and better at handling signals. For this reason, the exec form is recommended for `CMD` and `ENTRYPOINT`, while the shell form is mainly useful when you need shell features.

#### `ENV`

> **`ENV`** is used to **set environment variables** inside a Docker image.

```dockerfile
ENV IP="127.0.0.1"
```

> **`ENV` defines environment variables that exist both during build and at runtime inside the container.**

#### `USER`

> **`USER`** sets **which user** the container will run as for all subsequent instructions and at runtime.

```dockerfile
USER <username | UID>[:<group | GID>]
```

```dockerfile
USER alpha
```

```dockerfile
USER 1001:1001
```

> **`USER` defines which user executes commands and runs the container process.**

#### `WORKDIR`

> **`WORKDIR`** sets the **working directory** for any subsequent instructions (`RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD`) in the Dockerfile.

- If the directory **does not exist**, Docker **creates it automatically**
- All following commands run **inside this directory**
- It’s similar to running `cd <path>` in a shell

```dockerfile
WORKDIR <path>
```

```dockerfile
RUN useradd alpha
USER alpha
WORKDIR /home/alpha
RUN echo "test" pass.txt
```

> **`WORKDIR` sets the default directory where all subsequent commands run inside the container.**

#### `VOLUME`

> **`VOLUME`** declares a **mount point** inside the container that is meant to store **persistent or shared data**.

- Creates a **mount point** inside the image
- Docker automatically mounts a **volume** at that path when the container runs
- Data stored there is **not part of the image layer**

```dockerfile
VOLUME ["/var/lib/mysql", "/mnt/storage"]
```

- Docker creates an **anonymous volume**

| **Important behavior:**

- Data in a volume **persists even after container deletion**
- Data is **not included in image layers**
- If files exist at that path in the image, they are **copied into the volume once**

| **Important limitations:**

- You **cannot control volume name** from Dockerfile
- You **cannot remove volumes** from Dockerfile
- Docker decides where the volume lives

#### `EXPOSE`

> **`EXPOSE`** tells Docker **which ports the container listens on**, but it **does not actually publish or open the port**.

```dockerfile
EXPOSE <port> [<port>/<protocol>]
```

- Acts as **documentation** for users of the image
- Informs Docker which ports are intended to be used
- Enables automatic port mapping when using `-P`

```dockerfile
EXPOSE 80
EXPOSE 443/tcp
```

```shell
sudo docker run -p 8080:80 -p 8081:443 <image>
```

or

```shell
sudo docker run -P <image>
```

- Automatically map each one to a **random available port on the host**

> **`-P` automatically publishes all EXPOSEd ports to random ports on the host.**

#### `CMD`

> **`CMD`** defines the **default command** that runs when a container starts.

- Runs **when the container starts**
- Provides **default behavior**
- Can be overridden using `docker run`

```dockerfile
CMD ["ping", "8.8.8.8"]
```

or

```dockerfile
CMD ping 8.8.8.8
```

#### `EBTRYPOINT`

> **`ENTRYPOINT`** defines the **main executable** that always runs when a container starts.

- Sets the **main process** of the container
- Arguments passed to `docker run` are appended
- Ideal for containers that behave like executables

> Unlike `CMD`, it is **not overridden by default** when you pass arguments to `docker run`.

```dockerfile
ENTRYPOINT ["ping"]
```

or

```dockerfile
ENTRYPOINT ping
```

```shell
sudo docker run -it <image> 8.8.8.8 -c 5
```

or

```dockerfile
ENTRYPOINT ["ping"]
CMD ["8.8.8.8", "-c", "5"]
```

```shell
sudo docker run -it <image> 
```

**Override `ENTRYPOINT` **

```shell
sudo docker run -it --entrypoint ls <image> /home
```

---
### `ENTRYPOINT` & `CMD` together

> When **`ENTRYPOINT`** and **`CMD`** are used together, Docker treats `ENTRYPOINT` as the **fixed executable** and `CMD` as the **default arguments** passed to it. If both are written in _exec form_, Docker combines them at runtime so that `ENTRYPOINT` runs first and `CMD` provides its parameters. For example, `ENTRYPOINT ["python", "app.py"]` with `CMD ["--debug"]` will execute `python app.py --debug`. If you pass arguments to `docker run`, they **replace only the CMD**, not the ENTRYPOINT.

> If `ENTRYPOINT` is written in shell form, Docker wraps it in `/bin/sh -c`, which breaks signal handling and makes argument passing unreliable. For predictable behavior, both `ENTRYPOINT` and `CMD` should usually be written in **exec form**. In short: use `ENTRYPOINT` to define _what always runs_, and `CMD` to define _default arguments that can be overridden_.

| **Why shell form breaks things? **

When Docker uses shell form, it runs this:

```shell
/bin/sh -c "your command"
```

So your app is **not PID 1**, the shell is.

That means:

- Signals go to the shell, not your app
- Your app may not shut down properly
- Docker stop may hang or force kill

**Note**: Docker combines `ENTRYPOINT` and `CMD` **only when both are in exec form**.

> When you use **`ENTRYPOINT` in exec form** and **`CMD` in shell form**, Docker does **not combine them**, because Docker only merges arguments when **both are in exec form**. In this case, the shell-form `CMD` is treated as a separate shell command (`/bin/sh -c "..."`) and is effectively **ignored**, so only the `ENTRYPOINT` runs. This happens because Docker cannot safely append a shell command as arguments to an exec-form entrypoint. As a result, the container runs only the `ENTRYPOINT` command, and the `CMD` has no effect. To make them work together, both must be written in **exec form**, or you must explicitly invoke a shell inside `ENTRYPOINT`.

> When you use **`ENTRYPOINT` in shell form** and **`CMD` in exec form**, Docker **does not merge them cleanly** either. The shell-form `ENTRYPOINT` is executed as `/bin/sh -c "<command>"`, and the `CMD` (even if written in exec form) is **converted into a string and appended** to that shell command. This means the shell receives the CMD as plain text, not as structured arguments, which often leads to unexpected behavior and broken signal handling. In practice, the shell becomes PID 1, your actual application runs as a child process, and signals like `SIGTERM` may not reach it correctly. Because of this, mixing shell-form `ENTRYPOINT` with exec-form `CMD` is unreliable and strongly discouraged; both should be written in **exec form** for predictable and safe behavior.

```dockerfile
ENTRYPOINT ["ping"]
CMD ["8.8.8.8", "-c", "5"]
```

```shell
ping 8.8.8.8 -c 5
```

```dockerfile
ENTRYPOINT ["ping"]
CMD 8.8.8.8 -c 5
```

```shell
ping
```

```dockerfile
ENTRYPOINT ping
CMD ["8.8.8.8", "-c", "5"]
```

```shell
/bin/sh -c "ping" # 8.8.8.8 -c 5 
```

```dockerfile
ENTRYPOINT ping 
CMD "8.8.8.8 -c 5"
```

```shell
/bin/sh -c "ping" # 8.8.8.8 -c 5 (ignored)
```

#### `SHELL`

> **`SHELL`** defines **which shell** Docker should use to run **shell-form instructions** like `RUN`, `CMD`, and `ENTRYPOINT`.

- `SHELL` only affects **shell-form** instructions
- It does **not** affect exec-form (`["cmd", "arg"]`)
- It persists for the rest of the Dockerfile (unless changed again)

```dockerfile
SHELL ["executable", "arguments"]
```

```dockerfile
SHELL ["/bin/bash", "-c"]
```

```dockerfile
RUN ["useradd", "alpha"]
```

```shell
/bin/bash -c "useradd alpha"
```

#### `HEALTHCHECK ... CMD ...`

> **`HEALTHCHECK`** defines how Docker should **check if a container is healthy**. It runs a command periodically inside the container and marks it as **healthy** or **unhealthy** based on the exit code.

```dockerfile
HEALTHCHECK [OPTIONS] CMD <command>
```

| **How it works?**

- Docker runs the command **inside the container**
- Exit code meanings:
    - `0` → healthy
    - `1` → unhealthy
    - `2` → reserved (treated as unhealthy)

```dockerfile
HEALTHCHECK \
  --interval=30s \
  --timeout=5s \
  --start-period=10s \
  --retries=3 \
  CMD curl -f http://localhost || exit 1
```

- `--interval` → time between checks
- `--timeout` → max time a check can take
- `--start-period` → grace period before checks begin
- `--retries` → failures before marking unhealthy

```shell
sudo docker inspect --format='{{.State.Health.Status}}' <container>
```

| **Best practices:**

- Avoid long-running checks
- Avoid heavy commands
- Use internal endpoints (e.g. `/health`)
- Always set a timeout

---
### Distroless Images

> **Distroless images** are Docker images that contain **only your application and its runtime dependencies**, and **nothing else** - no shell, no package manager, no OS utilities.

**Debugging**

```shell
sudo docker run -itd --ipc=shareable ubuntu bash
```

```shell
docker run -it --rm \
 --pid=container:<ubuntu> \
 --network=container:<ubuntu> \
 --ipc=container:<ubuntu> # --ipc=shareable \
 busybox:latest sh 
```

---
### `RUN` Types

#### `type=bind`

> A **bind mount** directly connects a directory from the **host filesystem** into the container. The container sees the real files from the host, and any change is immediately reflected both ways. This is mainly used for **development**, because it allows live file editing. However, it tightly couples the container to the host’s filesystem structure and is not portable or secure for production use.

```dockerfile
RUN --mount=type=bind,source=/home/user/app,target=/app ls /app
```

#### `type=volume`

> A **volume mount** stores data in a Docker-managed location on the host. Unlike bind mounts, Docker fully manages its lifecycle. Volumes are persistent, portable, and ideal for production data. They survive container deletion and are isolated from host directory structure.

```dockerfile
RUN --mount=type=volume,target=/data \
	echo "hello" > /data/file.txt
```

#### `type=cache`

> A **cache mount** is used only during the build process to speed things up. It allows reuse of previously downloaded or generated files (like dependencies), but it is **not included in the final image**. This is ideal for package managers and build tools.

```dockerfile
RUN --mount=type=cache,target=/root/.cache \
    pip install -r requirements.txt
```

#### `type=tmpfs`

> A **tmpfs mount** stores data in memory (RAM). It is extremely fast and completely ephemeral. Once the build step finishes, the data disappears. Useful for sensitive or temporary data that should never touch disk.

```dockerfile
RUN --mount=type=tmpfs,target=/tmp \
    echo "secret" > /tmp/data
```

#### `type=secret`

> A **secret mount** securely injects sensitive data (API keys, tokens, passwords) during build time. The secret never appears in the image layers or filesystem after the build finishes.

```dockerfile
RUN --mount=type=secret,id=my_secret \
    cat /run/secrets/my_secret
```

#### `type=ssh`

> An **SSH mount** allows the build process to temporarily access your SSH agent. This is useful for cloning private repositories without exposing private keys inside the image.

```dockerfile
RUN --mount=type=ssh git clone git@github.com:private/repo.git
```

> Each mount type exists for a **specific lifecycle purpose** - **bind** for development, **volume** for persistence, **cache** for speed, **tmpfs** for security, and **secret/ssh** for sensitive operations.

---
### Docker `history`

> The `docker history` command shows the **history of an image**, including how each layer was created.

- Understand **how an image was built**
- Identify **large layers** that increase image size
- Debug **unexpected behavior**
- Optimize Dockerfiles by reducing layers

```shell
sudo docker history <image>
```

---
### Docker Restart Policy

> A **restart policy** tells Docker **when and how to automatically restart a container** if it stops or crashes.

```shell
sudo docker run --restart <policy> <image>
```

- `no`
	The container will not restart automatically under any condition. If it stops or crashes, it will remain stopped until it is manually started again. This is the default behavior and is useful for one-time tasks or debugging.

- `on-failure`
	The container restarts only if it exits with a non-zero status (meaning an error occurred). It will not restart if the container is stopped manually. This policy is useful for services that may fail temporarily and need automatic recovery.

- `always`
	The container always restarts when it stops unless it is manually stops, regardless of the exit reason. If the Docker daemon restarts, the container will start automatically again. Even if it stops manually.

- `unless-stopped`
	The container behaves like `always`, but with one difference: if you manually stop the container, it will not restart again - even after a system or Docker restart. This is useful when you want persistent services but still want manual control.

```shell
sudo docker inspect \
 --format='{{.HostConfig.RestartPolicy.Name}}' \
 <container>
```

