
### Docker `stop`

> Gracefully stops a running container by sending **SIGTERM** first, then **SIGKILL** if it doesn’t exit within the timeout.

```shell
sudo docker stop <container>
```

- Docker sends **SIGTERM** to the container’s **main process (PID 1)**  
	this asks the application to shut down cleanly (close connections, save state).

- Docker waits for a **grace period** (default **10 seconds**, configurable with `-t`)

- If the process is still running after the timeout, Docker sends **SIGKILL**  
	this forcefully terminates the container.

| **Important details**

- Only the **main process** receives the signal
- If the main process ignores SIGTERM, the container will be **killed**
- After stopping, the container state becomes **exited**, not removed

```shell
sudo docker stop -t 20 nginx
```

- `-t` time to wait before force killing the container (default: **10s**)

---
### Docker `wait`

> `docker wait` **blocks until a container stops**, then prints the container’s **exit code**.

```shell
sudo docker wait <container>
```

- Waits while the container is running
- Returns **only after** the container exits
- Outputs the **exit status** of the container’s main process

---
### Docker `start`

> `docker start` **starts an existing stopped container**.

```shell
sudo docker start <container>
```

```shell
sudo docker start -ai <id/name>
```

- **`-a` (attach)**  
    Attaches your terminal to the container’s **STDOUT and STDERR**.

- **`-i` (interactive)**  
    Keeps **STDIN open**, allowing you to send input (keyboard) to the container.
    
---
### Docker `restart`

> `docker start` starts a **stopped container** using its original configuration and command, without creating a new container.

```shell
sudo docker restart <container>
```

```shell
sudo docker restart -t 20 <container>
```

-  `-t` Gracefully restarts a container, giving it **20 seconds** to stop before forcing termination.

---
### Docker `kill`

> Immediately stops a container by sending **SIGKILL**, without waiting for graceful shutdown.

```shell
sudo docker kill <container>
```

- `-s, --signal <signal>`  
    Specify which signal to send (default: **SIGKILL**)


| **Common signals**:

- `SIGKILL` → force stop immediately
- `SIGTERM` → request graceful shutdown
- `SIGINT` → like pressing `Ctrl+C`

```shell
sudo docker kill -s SIGTERM ngnix
```

---
### Container Logs

> Shows the **STDOUT and STDERR logs** produced by a container since it started.

```shell
sudo docker logs <container>
```

| **Common options (flags)**

- `-f, --follow`  
    Stream logs in real time (like `tail -f`)

- `--tail <number>`  
    Show only the last N lines

- `--since <time>`  
    Show logs since a timestamp or duration (e.g. `10m`, `2025-01-01T10:00:00`)

- `--until <time>`  
    Show logs up to a timestamp or duration

- `-t, --timestamps`  
    Show timestamps for each log line

```shell
sudo docker logs -tf ngnix
```

```shell
sudo docker logs --tail 50 -t ngnix # last 50 lines with timestamps
```

```shell
sudo docker logs --since 10m nginx
#
sudo docker logs --since "2025-01-01T12:00:00" nginx
```

```shell
sudo docker logs --until 5m nginx
```

---
### Docker `events`


> Streams **real-time Docker events** from the daemon (containers, images, networks, volumes, etc.).

```shell
sudo docker events
```

| **Common options (flags)**

- `--since <time>`  
    Show events since a specific time (`10m`, `1h`, `RFC3339` timestamp)

- `--until <time>`  
    Show events until a specific time

- `--filter <key=value>`  
    Filter events (very commonly used)

| **What it reports**:

- Container events (start, stop, die, restart)
- Image events (pull, tag, delete)
- Network and volume events

**Filter by event type (only container start/stop)**

```shell
sudo docker events --filter type=container --filter event=start
```

**Filter by container name or ID**

```shell
sudo docker events --filter container=nginx
```

**Filter by image**

```shell
sudo docker events --filter image=nginx:latest
```

**Filter by time (since / until)**

```shell
docker events --since 10m
#
docker events --until "2025-01-01T12:00:00"
```

**Filter multiple events**

```shell
sudo docker events \
  --filter type=container \
  --filter event=die \
  --filter event=restart
```

**Filter by label**

```shell
sudo docker events --filter label=env=prod
```

---
### Docker `pause`

>  freezes all processes in a running container using cgroups, without stopping it.

```shell
sudo docker pause <container>
```

| **How it works (simple):**

- Docker uses **cgroups freezer**
- CPU execution is stopped
- Memory stays allocated
- Container state becomes `paused`

### Docker `unpause`

> resumes the container and continues execution from where it was paused.

```shell
sudo docker unpause <container>
```

---
### Docker `rename`

> Renames an **existing container** without stopping it.

```shell
sudo docker rename <container> <new-name>
```

---
### Docker `commit`

> Creates a new Docker image from the current state of a container and saves it with the given repository name and tag.

```shell
sudo docker commit <container> <repository:tag>
```

| **Common options (flags)**

- `-a, --author <name>`  
    Set image author metadata

- `-m, --message <msg>`  
    Commit message (like a Git commit)

- `--pause`  
    Pause container during commit (default: `true`)

- `--change <instruction>`  
    Apply Dockerfile instructions (e.g. `CMD`, `ENV`, `EXPOSE`)

> This command **creates a new image from a container and changes its default command**

```shell
sudo docker commit --change='CMD ["bin/bash"]' ngnix ngnix:modified
```

---
### Docker `save`

> Exports the specified Docker image into a tar archive file (`output.tar.gz`) so it can be transferr‍‍‍ed or stored and later loaded on another system.

```shell
sudo docker save -o output.tar.gz <repository:tag>
```

### Docker `load`

> Imports a Docker image from a tar archive (`output.tar.gz`) into the local Docker image store.


```shell
sudo docker load < output.tar.gz
# or
sudo docker load -i output.tar.gz
```

---
### Docker `export`

> Exports a container’s **filesystem only** into a tar file, without image metadata, history, or configuration.

```shell
sudo docker export <container> > output.tar
```

### Docker `import`

> Imports a tar file as a **new Docker image**, creating an image from the container’s filesystem **without history, metadata, or configuration**.

```shell
sudo dcoker import output.tar
```

> In Docker, **history, metadata, and configuration** are the parts of an image that describe **how the image was built and how it should run**, not the files themselves.

- **History**  
    Records how the image was created (Dockerfile layers, commands like `RUN`, `COPY`, build steps).

- **Metadata**  
    Descriptive information such as image ID, labels, creation time, architecture, OS, and environment variables.

- **Configuration**  
    Runtime defaults, including:
    
    - `CMD` / `ENTRYPOINT`
    - `ENV`
    - `WORKDIR`
    - `EXPOSE`
    - `USER`
    - Volumes and stop signals

| **Key difference:**
- `docker commit` → keeps history, metadata, and configuration
- `docker export` / `docker import` → only filesystem, everything else is lost

---
### Log Driver

> A **log driver** is the Docker component that controls **where and how container logs are stored or sent**.

```shell
sudo docker info | grep -i "logging driver" # Defaul json-file
# or
sudo docker info --format '{{.LoggingDriver}}'
```

```json
{
	"log-driver": "<driver>"
}
```

**log drivers:**

- `json-file` (default)
- `journald`
- `syslog`
- `fluentd`
- `awslogs`

```json
{
	"log-driver": "<driver>",
	"log-opt": {
		"max-size": "10m",
		"max-file": "3",
		"labels": "label",
		"env": "os, customer"
	}
}
```

- **`"max-size": "10m"`**  
    Rotates a log file when it reaches **10 MB**.

- **`"max-file": "3"`**  
    Keeps **up to 3 rotated log files** (older ones are deleted).

- **`"labels": "label"`**  
    Includes specified **container labels** in log records (useful for filtering).    

- **`"env": "os, customer"`**  
    Includes specified **environment variables** in log records.

> Runs a container using the **specified log driver**, overriding the Docker daemon’s default logging configuration for that container.

```shell
sudo docker run --log-driver <driver> <image>
```

```shell
sudo docker inspect -f "{{.HostConfig.LogConfig.Type}}" <container>
```

> Runs a container with **non-blocking logging**, so the application is **not slowed or blocked** if the logging system can’t keep up.

```shell
sudo docker run --log-opt mode="non-blocking" --log-opt max-buffer-size=4m <image>
```

- **`mode=non-blocking`** → container keeps running even if logs can’t be written immediately

- **`max-buffer-size=4m`** → up to **4 MB** of logs are buffered in memory before dropping old logs

> **Blocking vs Non-blocking logging** differ in how Docker handles log backpressure:

- **Blocking**: the container’s writes to stdout/stderr **wait** until the log driver accepts them. If the log system is slow or unavailable, the application can **stall or freeze**.

- **Non-blocking**: Docker **buffers logs in memory** and lets the application continue. If the buffer fills, **older logs are dropped** to keep the app running.

> `--log-opt tag="..."` defines a **template for labeling each log entry** with runtime metadata, mainly for **centralized logging systems** (syslog, fluentd, awslogs, gelf).

- Docker expands **placeholders** at runtime.
- The expanded value becomes the **log tag** attached to every log line.
- Log backends use this tag to **route, index, and filter** logs.

```shell
docker run \
  --log-driver syslog \
  --log-opt tag="{{.ImageName}}/{{.ContainerName}}" \
  nginx
```

| **Common placeholders**

- `{{.ContainerName}}` → container name
- `{{.ContainerID}}` → container ID
- `{{.ImageName}}` → image name
- `{{.DaemonName}}` → Docker daemon name
- `{{.ID}}` → short container ID

---
### Docker Volume

> A **Docker volume** is a managed storage location used to **persist data outside a container’s lifecycle**.

- Data in a volume **survives container stop, removal, or recreation**
- Volumes are **managed by Docker**, not tied to the container filesystem
- Multiple containers can **share the same volume**
