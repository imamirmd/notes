
> Docker provides **three main ways** to mount data into a container, each designed for a different purpose.

1. **Volumes** are Docker-managed storage. Docker creates and controls the location on disk, so containers stay portable and data survives container removal. Volumes are the **recommended choice for production** because they are stable, secure, and independent of the host directory structure.

2. **Bind mounts** map an existing **host path** directly into the container. The container sees the exact host files, and changes are reflected immediately. This is very useful for **development and configuration**, but it tightly couples the container to the host filesystem and is less portable.

3. **tmpfs mounts** store data **only in memory (RAM)**. Nothing is written to disk, and all data is lost when the container stops. This is ideal for **temporary or sensitive data** where speed and security matter.

---
### Docker Volumes (Managed by Docker) & Bind Mounts

> **Volumes** are Docker’s **native, managed storage mechanism** for persisting data outside the container filesystem.

- A volume is a **directory on the Docker host** that Docker fully manages
- Containers **mount** that directory at a path inside the container
- The container sees it like a normal folder, but it **lives independently** of the container

| **How volumes work internally ?**

- Stored under Docker’s data directory (commonly `/var/lib/docker/volumes/`)
- Each volume has a **name**, and a **mountpoint**
- Docker mounts the volume into the container using the storage driver

> **Bind mounts** map an **existing file or directory on the host** directly into a container.

- A bind mount is a **direct reference to a host path**
- Docker does **not manage** the data or its location
- The container sees the **exact same files** the host sees

| **How bind mounts work internally ?**

- Docker asks the kernel to **mount the host path** into the container’s mount namespace
- No copying, no abstraction
- Permissions, ownership, and SELinux/AppArmor rules come **from the host**

| **The container:**
- can read/write freely
- cannot tell whether the data is local or mounted

**List of volumes**

```shell
sudo docker volume ls
```

```shell
sudo docker volume ls -f <key=value>
```

- `-f, --filter <key=value>` Filter volumes
	- `name=<pattern>`
	- `driver=<driver>`
	- `label=<key>` or `label=<key=value>`
    
- `-q, --quiet` show only volume names (IDs)

**Creating a volume**

```shell
sudo docker volume create <name>
```

- `-d, --driver <driver>`  
    Specify volume driver (default: `local`)

- `-o, --opt <key=value>`  
    Driver-specific options

- `--label <key=value>`  
    Add metadata labels to the volume

```shell
sudo docker volume create \
  --label env=prod \
  --label app=db \
  alpha
```

**Using the defined volume**

```shell
sudo docker run -v <volume>:<mount-point>[:(ro | rw) = rw] <image>
```

```shell
sudo docker run -it -v alpha:/alpha:rw --name alpha busybox sh
```

> Shows **detailed metadata and configuration** of a Docker volume in JSON format.

```shell
sudo docker inspect <volume>
```

> Creates and starts an **interactive container**, mounts `/home` from the host into the container, names it `alpha`, and opens a shell (**Bind Mount**)

```shell
sudo docker run -it -v /home:/mnt/store --name alpha busybox sh
```

> Creates and starts an **interactive container**, attaches an **anonymous volume** to `/mnt/store`, names the container `alpha`, and opens a shell.

```shell
sudo docker run -it -v /mnt/store --name alpha busybox sh
```

**Using multiple volumes**

```shell
sudo docker run -it --name alpha \
 -v val1:/mnt/db \
 -v val2:/mnt/share \
 ngnix
```

**Filtering containers by the volume name**

```shell
sudo docker ps -a --filter volume=<name>
```

**Displaying mounted volumes in the container**

```shell
sudo docker inspect --filter "{{.Mounts}}" <container>
```

> Deletes a **Docker volume** and **permanently removes its data**.

- Volume must **not be in use** by any container
- Both running **and stopped** containers can block removal
- Data is deleted from disk

```shell
sudo docker volume rm <name>
```

- `-f, --force`  Force removal (still fails if volume is actively used)

> Removes **anonymous local Docker volumes** (volumes not referenced by any container).

```shell
sudo docker volume prune
```

- `-f, --force`  
    Skip confirmation prompt


> You can add a volume to a Docker container **only at creation time** using `docker run`, and you **cannot add or remove volumes** from a running or stopped container. To change volumes, you must stop and remove the container and then recreate it with the desired mounts. Volumes live independently from containers, so removing a container does not delete the data unless the volume itself is removed.


| **NFS server as a Docker volume:**

```shell
sudo docker volume create \
  --driver local \
  --opt type=nfs \
  --opt o=addr=192.168.1.10,rw \
  --opt device=:/exports/docker-data \
  nfs_volume
```

- `type=nfs` → use NFS
- `addr=192.168.1.10` → NFS server IP
- `rw` → read/write
- `device=:/exports/docker-data` → exported path on NFS server

**Common NFS options (`-o`): **

```md
rw            read/write
ro            read-only
hard          retry forever (recommended)
soft          fail after timeout (NOT recommended for data)
nolock        disable locking (sometimes needed)
nfsvers=4     force NFS v4
```

**Another way of mounting a volume**

> There is **no functional difference** between `-v` and `--mount` in what they do; the difference is **syntax, clarity, and safety**.

```shell
sudo docker run -it \
  --mount \
  type=(volume | bind), \
  source=<volume>, \
  target=<mount-point>[,readonly] \
  busybox sh
```

`-v`:
- If `<volume>` exists → Docker uses it as a **volume**
- If `<volume>` does NOT exist → Docker **creates a new volume automatically**

`--mount`:
- Docker **fails** if the volume doesn’t exist
- No silent behavior

> If you mount a volume or a path to a container and they have files or directories in common, the data inside the volume/path takes priority and overrides the files inside the container.

> When you bind-mount a **single file** into a Docker container, Docker mounts the file’s **inode**, not just its filename. Commands like `echo >> file` modify the file **in place**, so the inode stays the same and the container immediately sees the change. Editors like **vim** usually save by writing to a temporary file and then **replacing** the original file, which creates a **new inode**. Since the bind mount is still pointing to the old inode, the container does not see the updated content. This is why mounting a **directory** instead of a single file avoids the problem.

> When you bind-mount a **directory**, Docker mounts the **directory path itself**, not a specific file inode. If you edit a file inside that directory with **vim**, even though vim saves by replacing the file (creating a new inode), the new file is still created **inside the mounted directory**. Because the directory remains the same mount point, the container immediately sees the updated file. The inode problem only happens when you bind-mount a **single file**, not when you mount a directory.

```shell
sudo docker -it -v ./torrc.txt:/home/torrc.txt --name alpha busybox
```

---
### **`tmpfs` Mounts** (Memory-only)

> **tmpfs mounts** store data **entirely in memory (RAM)** and are **never written to disk**.

- A tmpfs mount is a **RAM-backed filesystem**
- Data exists only while the container is running
- When the container stops, **all data is lost**
- No files ever touch the disk

| **How tmpfs works internally ?**

- Docker asks the kernel to mount a **tmpfs filesystem**
- The filesystem lives in **memory pages**
- Memory usage is accounted via **cgroups**

| **Key properties ?**

- **Very fast** (RAM speed)
- **Ephemeral** (gone on stop/restart)
- **Secure** (no disk traces)
- **Counts against container memory limit**

```shell
sudo docker --tmpfs <container-path>[:options] <image>
```

```shell
sudo docker --mount type=tmpfs,target=<container-path>[,tmpfs-size=<bytes>] <image>
```

```shell
sudo docker --tmpfs /cache:size=64m busybox
```

```shell
sudo docker --mount type=tmpfs,target=/cache,tmpfs-size=67108864 busybox
```

